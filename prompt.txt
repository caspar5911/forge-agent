Got it. You want **ALL phases**, in the same **copy-pasteable, agent-safe style** as Phase 0 ‚Äî so you can hand each one to **GPT-5.2 as a coding agent** and move phase-by-phase without scope leaks.

Below is the **FULL SET OF PROMPTS ‚Äî PHASE 0 ‚Üí PHASE 7**.
These are **STRICT**, intentionally boring, and designed to keep Forge correct.

Freeze these. Reuse them exactly.

---

# üîí FORGE ‚Äî COMPLETE AGENT PROMPT SET

---

## PHASE 0 ‚Äî EXTENSION SHELL (FOUNDATION)

```
You are implementing PHASE 0 of a project called ‚ÄúForge‚Äù.

GOAL
Create a minimal VS Code extension shell that activates and exposes a single command.

YOU MUST BUILD
- A VS Code extension in TypeScript
- A command: forge.run
- The command shows a confirmation message (‚ÄúForge is alive‚Äù)

YOU MUST NOT
- Add any LLM logic
- Add any file scanning
- Add any planning logic
- Add any folders beyond what is required
- Add TODOs or placeholders

FILES YOU MAY TOUCH
- package.json
- src/extension.ts
- minimal tsconfig files

SUCCESS
- Extension activates
- Command runs
- No other behavior exists

Choose the simplest option if unsure.
```

---

## PHASE 1 ‚Äî CONTEXT HARVESTER (REALITY GROUNDING)

```
You are implementing PHASE 1 of Forge: the Context Harvester.

GOAL
Deterministically describe the current workspace. No intelligence. No guessing.

YOU MUST BUILD
A function that returns a structured object containing:
- workspaceRoot
- activeEditorFile (if any)
- files (depth-limited, relative paths)
- parsed package.json (if present)
- packageManager (npm / pnpm / yarn / null)
- frontendFramework (react / vue / null)
- backendFramework (express / nest / null)

YOU MUST NOT
- Use any LLM
- Infer architecture
- Guess missing values
- Modify files
- Plan tasks

FILES YOU MAY TOUCH
- src/context/*

SUCCESS
- Running forge.run logs the context object
- Output is deterministic and truthful
```

---

## PHASE 2 ‚Äî TASK COMPRESSOR (SHORT PROMPT EXPANSION)

```
You are implementing PHASE 2 of Forge: the Task Compressor.

GOAL
Convert a short user instruction into an explicit, step-by-step task plan.

INPUTS
- User instruction (string)
- ProjectContext object

YOU MUST BUILD
- A function that outputs an ordered task list (text or JSON)
- Ask for clarification if the instruction is ambiguous

YOU MUST NOT
- Read or modify files
- Execute tools
- Decide file paths alone
- Declare success

LLM USAGE
- Allowed ONLY for rewriting intent into steps

FILES YOU MAY TOUCH
- src/compressor/*

SUCCESS
- Short prompts expand into sensible, explicit task plans
```

---

## PHASE 3 ‚Äî PLANNER (AGENT BRAIN)

```
You are implementing PHASE 3 of Forge: the Planner.

GOAL
Select the next single safe action to perform.

INPUTS
- Task plan
- ProjectContext
- Previous tool results (if any)

YOU MUST BUILD
- A planner loop that emits ONE tool call at a time
- Output MUST be machine-readable JSON

EXAMPLE OUTPUT
{ "tool": "read_file", "path": "src/App.jsx" }

YOU MUST NOT
- Modify files directly
- Emit multi-file actions
- Skip steps
- Declare completion

LLM USAGE
- Allowed ONLY for step selection and tool choice

FILES YOU MAY TOUCH
- src/planner/*

SUCCESS
- Planner emits boring, predictable tool calls
```

---

## PHASE 4 ‚Äî TOOL EXECUTOR + DIFF GUARD (SAFETY CORE)

```
You are implementing PHASE 4 of Forge: Tool Execution and Diff Guard.

GOAL
Apply real effects safely and deterministically.

YOU MUST BUILD
Tools for:
- read_file
- apply_diff (unified diff only)
- run_command

RULES
- Reject invalid diffs
- Block full-file rewrites
- One file per diff
- Roll back on failure

YOU MUST NOT
- Use any LLM
- Make semantic decisions
- Retry automatically
- Touch Git

FILES YOU MAY TOUCH
- src/tools/*

SUCCESS
- One-file edits succeed without corruption
```

---

## PHASE 5 ‚Äî VALIDATION GATE (TRUTH ENFORCEMENT)

```
You are implementing PHASE 5 of Forge: Validation Gate.

GOAL
Verify that changes are real and correct.

YOU MUST BUILD
- Ability to run build/test/typecheck commands
- Capture stdout/stderr
- Fail on any error

RULES
- No success if validation fails
- Retries allowed ONLY for mechanical failures
- No guessing fixes

YOU MUST NOT
- Use any LLM
- Ignore failures
- Commit code

FILES YOU MAY TOUCH
- src/validation/*

SUCCESS
- Forge never reports success if tests fail
```

---

## PHASE 6 ‚Äî GIT MANAGER (HUMAN-IN-THE-LOOP)

```
You are implementing PHASE 6 of Forge: Git Manager.

GOAL
Integrate Git safely with explicit user consent.

YOU MUST BUILD
- Diff summary generation
- Commit message generation
- Commit execution
- Optional push to branch

RULES
- No auto-commit
- No auto-push
- Never push to main by default
- Validation must pass first

LLM USAGE
- Allowed ONLY for commit message generation

FILES YOU MAY TOUCH
- src/git/*

SUCCESS
- Git actions occur only after user approval
```

---

## PHASE 7 ‚Äî UX POLISH (OPTIONAL)

```
You are implementing PHASE 7 of Forge: UX Polish.

GOAL
Improve usability without adding intelligence.

YOU MAY ADD
- Progress indicators
- Step logs
- Confirmation dialogs

YOU MUST NOT
- Add new planning logic
- Add hidden automation
- Add background agents

FILES YOU MAY TOUCH
- src/extension.ts
- minimal UI helpers

SUCCESS
- UX is smoother without changing behavior
```

---

# üß† HOW TO USE THIS SET (IMPORTANT)

**Rules**

* Run **ONE phase at a time**
* Commit after every phase
* If the agent violates scope ‚Üí discard output

**Commit pattern**

* Phase 0 ‚Üí `scaffold`
* Phase 1 ‚Üí `feat(context)`
* Phase 2 ‚Üí `feat(compressor)`
* Phase 3 ‚Üí `feat(planner)`
* Phase 4 ‚Üí `feat(tools)`
* Phase 5 ‚Üí `feat(validation)`
* Phase 6 ‚Üí `feat(git)`
* Phase 7 ‚Üí `chore(ux)`

---

## FINAL MENTOR VERDICT

You now have:

* A **full phase plan**
* **Exact agent prompts**
* Hard scope boundaries
* A system that cannot accidentally turn into chaos

This is how **real agentic systems** are built.

---

### Next (pick ONE)

1Ô∏è‚É£ Phase 2 Task Compressor ‚Äî **deeper rules + examples**
2Ô∏è‚É£ Planner tool schema (exact JSON contracts)
3Ô∏è‚É£ Diff Guard edge cases checklist

Say the number.
